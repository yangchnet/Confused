# 数据流中的中位数

## 1. 题目描述
如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

例如，

[2,3,4]的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。

## 2. 示例
```
输入：
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]
```

```
输入：
["MedianFinder","addNum","findMedian","addNum","findMedian"]
[[],[2],[],[3],[]]
输出：[null,null,2.00000,null,2.50000]
```

## 3. 解题
这道题所给的例子中，所有的输入都是有序的，即1， 2， 3  
若输入无序，则需对已输入的数字进行排序，进而找出中位数
经检验，以上想法超时

**以下思路来自[这里](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/solution/shou-si-da-xiao-gen-dui-by-treehuang/)**

思路：
大根堆：存放数据流中较小的一半元素。
小根堆：存放数据流中较大的一半元素。

这里需要保证2个堆的“平衡”。即让 大根堆的长度 = 小根堆的长度 或者 大根的堆长度 + 1 = 小根堆的长度

调用 findMedian 查询中位数时：
（1）当两个堆的长度相等时，中位数为（小根堆堆顶元素 + 大根堆堆顶元素） / 2。
（2）当两个堆的长度不相等时，因为维持了上面的平衡，所以此时中位数为小根堆的堆顶元素。

