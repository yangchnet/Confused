# 问题描述
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

示例 1：

输入：[3,4,5,1,2]
输出：1
示例 2：

输入：[2,2,2,0,1]
输出：0

# 解决思路
1. 遍历法  
    直接遍历即可得出其最小值O（n）
2. 使用跳表

3. 使用二分查找
    思路：数组中最特殊的位置是左边位置 left 和右边位置 right，将它们与中间位置 mid 的值进行比较，进而判断最小数字出现在哪里。
    
    用左边位置 left 和中间位置 mid 的值进行比较是否可以？
    举例：[3, 4, 5, 1, 2] 与 [1, 2, 3, 4, 5] ，此时，中间位置的值都比左边大，但最小值一个在后面，一个在前面，因此这种做法不能有效地减治。
    
    用右边位置 right 和中间位置 mid 的值进行比较是否可以？
    举例：[1, 2, 3, 4, 5]、[3, 4, 5, 1, 2]、[2, 3, 4, 5 ,1]，用右边位置和中间位置的元素比较，可以进一步缩小搜索的范围。
    
    补充说明：遇到 nums[mid] == nums[right] 的时候，不能草率地下定结论最小数字在哪一边，但是可以确定的是，把 right 舍弃掉，并不影响结果。
    注意我们绝对不会错过最小值。我们反过来想，如果我们错过了最小值说明nums[right]就是唯一的最小值，这和nums[mid] == nums[right]矛盾。
    